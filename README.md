# What

## Brief
Javascript & TypeScript Data Structure Library. 

Meticulously crafted to empower developers with a versatile set of essential data structures. Our library includes a
wide range of data structures

## Data Structures

<table>
<thead>
<tr>
<th>Data Structure</th>
<th>Unit Test</th>
<th>Performance Test</th>
<th>API Documentation</th>
<th>Implemented</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary Tree</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt="">
</img></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt="">
</img></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/BinaryTree.html"><span>Binary Tree</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Binary Search Tree (BST)</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/BST.html"><span>BST</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>AVL Tree</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/AVLTree.html"><span>AVLTree</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Tree Multiset</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/TreeMultiSet.html"><span>TreeMultiSet</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Segment Tree</td>
<td></td>
<td></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/SegmentTree.html"><span>SegmentTree</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Binary Indexed Tree</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/BinaryIndexedTree.html"><span>BinaryIndexedTree</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Graph</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/AbstractGraph.html"><span>AbstractGraph</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Directed Graph</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/DirectedGraph.html"><span>DirectedGraph</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Undirected Graph</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/UndirectedGraph.html"><span>UndirectedGraph</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Linked List</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/SinglyLinkedList.html"><span>SinglyLinkedList</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Singly Linked List</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/SinglyLinkedList.html"><span>SinglyLinkedList</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Doubly Linked List</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/DoublyLinkedList.html"><span>DoublyLinkedList</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Queue</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/Queue.html"><span>Queue</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Object Deque</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/ObjectDeque.html"><span>ObjectDeque</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Array Deque</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/ArrayDeque.html"><span>ArrayDeque</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Stack</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/Stack.html"><span>Stack</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>

[//]: # (<tr>)

[//]: # (<td>Hash</td>)

[//]: # (<td></td>)

[//]: # (<td></td>)

[//]: # (<td><a href="https://data-structure-typed-docs.vercel.app/classes/HashTable.html"><span>HashTable</span></a></td>)

[//]: # (<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>)

[//]: # (</tr>)
<tr>
<td>Coordinate Set</td>
<td></td>
<td></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/CoordinateSet.html"><span>CoordinateSet</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Coordinate Map</td>
<td></td>
<td></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/CoordinateMap.html"><span>CoordinateMap</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Heap</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/Heap.html"><span>Heap</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Priority Queue</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/PriorityQueue.html"><span>PriorityQueue</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Max Priority Queue</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/MaxPriorityQueue.html"><span>MaxPriorityQueue</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Min Priority Queue</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/MinPriorityQueue.html"><span>MinPriorityQueue</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
<tr>
<td>Trie</td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
<td></td>
<td><a href="https://data-structure-typed-docs.vercel.app/classes/Trie.html"><span>Trie</span></a></td>
<td><img src="https://raw.githubusercontent.com/zrwusa/assets/master/images/data-structure-typed/assets/tick.svg" alt=""></td>
</tr>
</tbody>
</table>

## Algorithms list only a few out, you can discover more in API docs

DFS, DFSIterative, BFS, morris, Bellman-Ford Algorithm, Dijkstra's Algorithm, Floyd-Warshall Algorithm, Tarjan's Algorithm

# How

[API Docs](https://data-structure-typed-docs.vercel.app)

[Live Examples](https://data-structure-typed-examples.vercel.app)


![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/examples/dfs-pre-order.webp)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/examples/test-graphs.webp)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/examples/cut-off-trees-for-golf.webp)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/examples/parenthesis-check.webp)

<a href="https://data-structure-typed-examples.vercel.app" target="_blank">Live Examples</a>

## install

### yarn

```bash
yarn add data-structure-typed
```

### npm

```bash
npm install data-structure-typed
```

### Binary Search Tree (BST) snippet

```typescript
    import {BST, BSTNode} from 'data-structure-typed';

    const tree = new BST();
    expect(tree).toBeInstanceOf(BST);

    const ids = [11, 3, 15, 1, 8, 13, 16, 2, 6, 9, 12, 14, 4, 7, 10, 5];
    tree.addMany(ids);
    expect(tree.root).toBeInstanceOf(BSTNode);
    if (tree.root) expect(tree.root.id).toBe(11);
    expect(tree.count).toBe(16);
    expect(tree.has(6)).toBe(true);

    const node6 = tree.get(6);
    expect(node6 && tree.getHeight(node6)).toBe(2);
    expect(node6 && tree.getDepth(node6)).toBe(3);

    const nodeId10 = tree.get(10, 'id');
    expect(nodeId10?.id).toBe(10);

    const nodeVal9 = tree.get(9, 'val');
    expect(nodeVal9?.id).toBe(9);

    const nodesByCount1 = tree.getNodes(1, 'count');
    expect(nodesByCount1.length).toBe(16);

    const leftMost = tree.getLeftMost();
    expect(leftMost?.id).toBe(1);

    const node15 = tree.get(15);
    const minNodeBySpecificNode = node15 && tree.getLeftMost(node15);
    expect(minNodeBySpecificNode?.id).toBe(12);

    const subTreeSum = node15 && tree.subTreeSum(node15);
    expect(subTreeSum).toBe(70);

    const lesserSum = tree.lesserSum(10);
    expect(lesserSum).toBe(45);

    expect(node15).toBeInstanceOf(BSTNode);
    if (node15 instanceof BSTNode) {
        const subTreeAdd = tree.subTreeAdd(node15, 1, 'count');
        expect(subTreeAdd).toBeDefined();
    }

    const node11 = tree.get(11);
    expect(node11).toBeInstanceOf(BSTNode);
    if (node11 instanceof BSTNode) {
        const allGreaterNodesAdded = tree.allGreaterNodesAdd(node11, 2, 'count');
        expect(allGreaterNodesAdded).toBeDefined();
    }

    const dfsInorderNodes = tree.DFS('in', 'node');
    expect(dfsInorderNodes[0].id).toBe(1);
    expect(dfsInorderNodes[dfsInorderNodes.length - 1].id).toBe(16);

    tree.balance();
    expect(tree.isBalanced()).toBe(true);

    const bfsNodesAfterBalanced = tree.BFS('node');
    expect(bfsNodesAfterBalanced[0].id).toBe(8);
    expect(bfsNodesAfterBalanced[bfsNodesAfterBalanced.length - 1].id).toBe(16);

    const removed11 = tree.remove(11, true);
    expect(removed11).toBeInstanceOf(Array);
    expect(removed11[0]).toBeDefined();
    expect(removed11[0].deleted).toBeDefined();

    if (removed11[0].deleted) expect(removed11[0].deleted.id).toBe(11);

    expect(tree.isAVLBalanced()).toBe(true);

    expect(node15 && tree.getHeight(node15)).toBe(2);

    const removed1 = tree.remove(1, true);
    expect(removed1).toBeInstanceOf(Array);
    expect(removed1[0]).toBeDefined();
    expect(removed1[0].deleted).toBeDefined();
    if (removed1[0].deleted) expect(removed1[0].deleted.id).toBe(1);

    expect(tree.isAVLBalanced()).toBe(true);

    expect(tree.getHeight()).toBe(4);

    // The code for removing these nodes (4, 10, 15, 5, 13, 3, 8, 6, 7, 9, 14) in sequence has been omitted.

    expect(tree.isAVLBalanced()).toBe(false);

    const bfsIDs = tree.BFS();
    expect(bfsIDs[0]).toBe(2);
    expect(bfsIDs[1]).toBe(12);
    expect(bfsIDs[2]).toBe(16);

    const bfsNodes = tree.BFS('node');
    expect(bfsNodes[0].id).toBe(2);
    expect(bfsNodes[1].id).toBe(12);
    expect(bfsNodes[2].id).toBe(16);
```

### Directed Graph simple snippet

```typescript
import {DirectedGraph, DirectedVertex, DirectedEdge, VertexId} from 'data-structure-typed';

let graph: DirectedGraph<DirectedVertex, DirectedEdge>;

    beforeEach(() => {
        graph = new DirectedGraph();
    });


    it('should add vertices', () => {
        const vertex1 = new DirectedVertex('A');
        const vertex2 = new DirectedVertex('B');

        graph._addVertexOnly(vertex1);
        graph._addVertexOnly(vertex2);

        expect(graph.hasVertex(vertex1)).toBe(true);
        expect(graph.hasVertex(vertex2)).toBe(true);
    });

    it('should add edges', () => {
        const vertex1 = new DirectedVertex('A');
        const vertex2 = new DirectedVertex('B');
        const edge = new DirectedEdge('A', 'B');

        graph._addVertexOnly(vertex1);
        graph._addVertexOnly(vertex2);
        graph._addEdgeOnly(edge);

        expect(graph.hasEdge('A', 'B')).toBe(true);
        expect(graph.hasEdge('B', 'A')).toBe(false);
    });

    it('should remove edges', () => {
        const vertex1 = new DirectedVertex('A');
        const vertex2 = new DirectedVertex('B');
        const edge = new DirectedEdge('A', 'B');

        graph._addVertexOnly(vertex1);
        graph._addVertexOnly(vertex2);
        graph._addEdgeOnly(edge);

        expect(graph.removeEdge(edge)).toBe(edge);
        expect(graph.hasEdge('A', 'B')).toBe(false);
    });

    it('should perform topological sort', () => {
        const vertexA = new DirectedVertex('A');
        const vertexB = new DirectedVertex('B');
        const vertexC = new DirectedVertex('C');
        const edgeAB = new DirectedEdge('A', 'B');
        const edgeBC = new DirectedEdge('B', 'C');

        graph._addVertexOnly(vertexA);
        graph._addVertexOnly(vertexB);
        graph._addVertexOnly(vertexC);
        graph._addEdgeOnly(edgeAB);
        graph._addEdgeOnly(edgeBC);

        const topologicalOrder = graph.topologicalSort();
        if (topologicalOrder) expect(topologicalOrder.map(v => v.id)).toEqual(['A', 'B', 'C']);
    });
```

### Directed Graph complex snippet

```typescript
import {DirectedGraph, DirectedVertex, DirectedEdge, VertexId} from 'data-structure-typed';

class MyVertex extends DirectedVertex {
    private _data: string;
    get data(): string {
        return this._data;
    }
    set data(value: string) {
        this._data = value;
    }

    constructor(id: VertexId, data: string) {
        super(id);
        this._data = data;
    }
}

class MyEdge extends DirectedEdge {
    private _data: string;
    get data(): string {
        return this._data;
    }
    set data(value: string) {
        this._data = value;
    }

    constructor(v1: VertexId, v2: VertexId, weight: number, data: string) {
        super(v1, v2, weight);
        this._data = data;
    }
}

describe('DirectedGraph Test3', () => {
    const myGraph = new DirectedGraph<MyVertex, MyEdge>();

    it('should test graph operations', () => {
        const vertex1 = new MyVertex(1, 'data1');
        const vertex2 = new MyVertex(2, 'data2');
        const vertex3 = new MyVertex(3, 'data3');
        const vertex4 = new MyVertex(4, 'data4');
        const vertex5 = new MyVertex(5, 'data5');
        const vertex6 = new MyVertex(6, 'data6');
        const vertex7 = new MyVertex(7, 'data7');
        const vertex8 = new MyVertex(8, 'data8');
        const vertex9 = new MyVertex(9, 'data9');
        myGraph._addVertexOnly(vertex1);
        myGraph._addVertexOnly(vertex2);
        myGraph._addVertexOnly(vertex3);
        myGraph._addVertexOnly(vertex4);
        myGraph._addVertexOnly(vertex5);
        myGraph._addVertexOnly(vertex6);
        myGraph._addVertexOnly(vertex7);
        myGraph._addVertexOnly(vertex8);
        myGraph._addVertexOnly(vertex9);

        myGraph._addEdgeOnly(new MyEdge(1, 2, 10, 'edge-data1-2'));
        myGraph._addEdgeOnly(new MyEdge(2, 1, 20, 'edge-data2-1'));

        expect(myGraph.getEdge(1, 2)).toBeTruthy();
        expect(myGraph.getEdge(2, 1)).toBeTruthy();
        expect(myGraph.getEdge(1, '100')).toBeFalsy();

        myGraph.removeEdgeBetween(1, 2);
        expect(myGraph.getEdge(1, 2)).toBeFalsy();

        myGraph._addEdgeOnly(new MyEdge(3, 1, 3, 'edge-data-3-1'));
        myGraph._addEdgeOnly(new MyEdge(1, 9, 19, 'edge-data1-9'));
        myGraph._addEdgeOnly(new MyEdge(9, 7, 97, 'edge-data9-7'));
        myGraph._addEdgeOnly(new MyEdge(7, 9, 79, 'edge-data7-9'));
        myGraph._addEdgeOnly(new MyEdge(1, 4, 14, 'edge-data1-4'));
        myGraph._addEdgeOnly(new MyEdge(4, 7, 47, 'edge-data4-7'));
        myGraph._addEdgeOnly(new MyEdge(1, 2, 12, 'edge-data1-2'));
        myGraph._addEdgeOnly(new MyEdge(2, 3, 23, 'edge-data2-3'));
        myGraph._addEdgeOnly(new MyEdge(3, 5, 35, 'edge-data3-5'));
        myGraph._addEdgeOnly(new MyEdge(5, 7, 57, 'edge-data5-7'));
        myGraph._addEdgeOnly(new MyEdge(7, 3, 73, 'edge-data7-3'));
        
        const topologicalSorted = myGraph.topologicalSort();
        expect(topologicalSorted).toBeNull();

        const minPath1to7 = myGraph.getMinPathBetween(1, 7);
        expect(minPath1to7).toBeInstanceOf(Array);
        if (minPath1to7 && minPath1to7.length > 0) {
            expect(minPath1to7).toHaveLength(3);
            expect(minPath1to7[0]).toBeInstanceOf(MyVertex);
            expect(minPath1to7[0].id).toBe(1);
            expect(minPath1to7[1].id).toBe(9);
            expect(minPath1to7[2].id).toBe(7);
        }

        const fordResult1 = myGraph.bellmanFord(1);
        expect(fordResult1).toBeTruthy();
        expect(fordResult1.hasNegativeCycle).toBeUndefined();
        const {distMap, preMap, paths, min, minPath} = fordResult1;
        expect(distMap).toBeInstanceOf(Map);
        expect(distMap.size).toBe(9);
        expect(distMap.get(vertex1)).toBe(0);
        expect(distMap.get(vertex2)).toBe(12);
        expect(distMap.get(vertex3)).toBe(35);
        expect(distMap.get(vertex4)).toBe(14);
        expect(distMap.get(vertex5)).toBe(70);
        expect(distMap.get(vertex6)).toBe(Infinity);
        expect(distMap.get(vertex7)).toBe(61);
        expect(distMap.get(vertex8)).toBe(Infinity);
        expect(distMap.get(vertex9)).toBe(19);

        expect(preMap).toBeInstanceOf(Map);
        expect(preMap.size).toBe(0);

        expect(paths).toBeInstanceOf(Array);
        expect(paths.length).toBe(0);
        expect(min).toBe(Infinity);
        expect(minPath).toBeInstanceOf(Array);
        
        const floydResult = myGraph.floyd();
        expect(floydResult).toBeTruthy();
        if (floydResult) {
            const {costs, predecessor} = floydResult;
            expect(costs).toBeInstanceOf(Array);
            expect(costs.length).toBe(9);
            expect(costs[0]).toEqual([32, 12, 35, 14, 70, Infinity, 61, Infinity, 19]);
            expect(costs[1]).toEqual([20, 32, 23, 34, 58, Infinity, 81, Infinity, 39]);
            expect(costs[2]).toEqual([3, 15, 38, 17, 35, Infinity, 64, Infinity, 22]);
            expect(costs[3]).toEqual([123, 135, 120, 137, 155, Infinity, 47, Infinity, 126]);
            expect(costs[4]).toEqual([133, 145, 130, 147, 165, Infinity, 57, Infinity, 136]);
            expect(costs[5]).toEqual([Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity]);
            expect(costs[6]).toEqual([76, 88, 73, 90, 108, Infinity, 137, Infinity, 79]);
            expect(costs[7]).toEqual([Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity]);
            expect(costs[8]).toEqual([173, 185, 170, 187, 205, Infinity, 97, Infinity, 176]);

            expect(predecessor).toBeInstanceOf(Array);
            expect(predecessor.length).toBe(9);
            expect(predecessor[0]).toEqual([vertex2, null, vertex2, null, vertex3, null, vertex4, null, null]);
            expect(predecessor[1]).toEqual([null, vertex1, null, vertex1, vertex3, null, vertex4, null, vertex1]);
            expect(predecessor[5]).toEqual([null, null, null, null, null, null, null, null, null]);
            expect(predecessor[7]).toEqual([null, null, null, null, null, null, null, null, null]);
            expect(predecessor[8]).toEqual([vertex7, vertex7, vertex7, vertex7, vertex7, null, null, null, vertex7]);
        }

        const dijkstraRes12tt = myGraph.dijkstra(1, 2, true, true);
        expect(dijkstraRes12tt).toBeTruthy();
        if (dijkstraRes12tt) {
            const {distMap, minDist, minPath, paths, preMap, seen} = dijkstraRes12tt;
            expect(distMap).toBeInstanceOf(Map);
            expect(distMap.size).toBe(9);
            expect(distMap.get(vertex1)).toBe(0);
            expect(distMap.get(vertex2)).toBe(12);
            expect(distMap.get(vertex3)).toBe(Infinity);
            expect(distMap.get(vertex4)).toBe(14);
            expect(distMap.get(vertex5)).toBe(Infinity);
            expect(distMap.get(vertex6)).toBe(Infinity);
            expect(distMap.get(vertex7)).toBe(Infinity);
            expect(distMap.get(vertex8)).toBe(Infinity);
            expect(distMap.get(vertex9)).toBe(19);

            expect(minDist).toBe(12);
            expect(minPath).toBeInstanceOf(Array);
            expect(minPath.length).toBe(2);
            expect(minPath[0]).toBe(vertex1);
            expect(minPath[1]).toBe(vertex2);

            expect(paths).toBeInstanceOf(Array);
            expect(paths.length).toBe(9);
            expect(paths[0]).toBeInstanceOf(Array);
            expect(paths[0][0]).toBe(vertex1);

            expect(paths[1]).toBeInstanceOf(Array);
            expect(paths[1][0]).toBe(vertex1);
            expect(paths[1][1]).toBe(vertex2);

            expect(paths[2]).toBeInstanceOf(Array);
            expect(paths[2][0]).toBe(vertex3);
            expect(paths[3]).toBeInstanceOf(Array);
            expect(paths[3][0]).toBe(vertex1);
            expect(paths[3][1]).toBe(vertex4);
            expect(paths[4]).toBeInstanceOf(Array);
            expect(paths[4][0]).toBe(vertex5);

            expect(paths[5]).toBeInstanceOf(Array);
            expect(paths[5][0]).toBe(vertex6);
            expect(paths[6]).toBeInstanceOf(Array);
            expect(paths[6][0]).toBe(vertex7);
            expect(paths[7]).toBeInstanceOf(Array);
            expect(paths[7][0]).toBe(vertex8);
            expect(paths[8]).toBeInstanceOf(Array);
            expect(paths[8][0]).toBe(vertex1);
            expect(paths[8][1]).toBe(vertex9);
        }
    });
});
```

## API docs


[//]: # ([Examples Repository]&#40;https://github.com/zrwusa/data-structure-typed-examples&#41;)

<a href="https://github.com/zrwusa/data-structure-typed-examples" target="_blank">Examples Repository</a>

# Why

## Complexities

### performance of Big O

<table>
<thead>
<tr>
<th>Big O Notation</th>
<th>Type</th>
<th>Computations for 10 elements</th>
<th>Computations for 100 elements</th>
<th>Computations for 1000 elements</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>O(1)</strong></td>
<td>Constant</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>O(log N)</strong></td>
<td>Logarithmic</td>
<td>3</td>
<td>6</td>
<td>9</td>
</tr>
<tr>
<td><strong>O(N)</strong></td>
<td>Linear</td>
<td>10</td>
<td>100</td>
<td>1000</td>
</tr>
<tr>
<td><strong>O(N log N)</strong></td>
<td>n log(n)</td>
<td>30</td>
<td>600</td>
<td>9000</td>
</tr>
<tr>
<td><strong>O(N^2)</strong></td>
<td>Quadratic</td>
<td>100</td>
<td>10000</td>
<td>1000000</td>
</tr>
<tr>
<td><strong>O(2^N)</strong></td>
<td>Exponential</td>
<td>1024</td>
<td>1.26e+29</td>
<td>1.07e+301</td>
</tr>
<tr>
<td><strong>O(N!)</strong></td>
<td>Factorial</td>
<td>3628800</td>
<td>9.3e+157</td>
<td>4.02e+2567</td>
</tr>
</tbody>
</table>

### Data Structure Complexity

<table>
<thead>
<tr>
<th>Data Structure</th>
<th>Access</th>
<th>Search</th>
<th>Insertion</th>
<th>Deletion</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Array</strong></td>
<td>1</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td><strong>Stack</strong></td>
<td>n</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><strong>Queue</strong></td>
<td>n</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><strong>Linked List</strong></td>
<td>n</td>
<td>n</td>
<td>1</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td><strong>Hash Table</strong></td>
<td>-</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>In case of perfect hash function costs would be O(1)</td>
</tr>
<tr>
<td><strong>Binary Search Tree</strong></td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>In case of balanced tree costs would be O(log(n))</td>
</tr>
<tr>
<td><strong>B-Tree</strong></td>
<td>log(n)</td>
<td>log(n)</td>
<td>log(n)</td>
<td>log(n)</td>
<td></td>
</tr>
<tr>
<td><strong>Red-Black Tree</strong></td>
<td>log(n)</td>
<td>log(n)</td>
<td>log(n)</td>
<td>log(n)</td>
<td></td>
</tr>
<tr>
<td><strong>AVL Tree</strong></td>
<td>log(n)</td>
<td>log(n)</td>
<td>log(n)</td>
<td>log(n)</td>
<td></td>
</tr>
<tr>
<td><strong>Bloom Filter</strong></td>
<td>-</td>
<td>1</td>
<td>1</td>
<td>-</td>
<td>False positives are possible while searching</td>
</tr>
</tbody>
</table>

### Sorting Complexity

<table>
<thead>
<tr>
<th>Name</th>
<th>Best</th>
<th>Average</th>
<th>Worst</th>
<th>Memory</th>
<th>Stable</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bubble sort</strong></td>
<td>n</td>
<td>n<sup>2</sup></td>
<td>n<sup>2</sup></td>
<td>1</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><strong>Insertion sort</strong></td>
<td>n</td>
<td>n<sup>2</sup></td>
<td>n<sup>2</sup></td>
<td>1</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><strong>Selection sort</strong></td>
<td>n<sup>2</sup></td>
<td>n<sup>2</sup></td>
<td>n<sup>2</sup></td>
<td>1</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><strong>Heap sort</strong></td>
<td>n&nbsp;log(n)</td>
<td>n&nbsp;log(n)</td>
<td>n&nbsp;log(n)</td>
<td>1</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><strong>Merge sort</strong></td>
<td>n&nbsp;log(n)</td>
<td>n&nbsp;log(n)</td>
<td>n&nbsp;log(n)</td>
<td>n</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><strong>Quick sort</strong></td>
<td>n&nbsp;log(n)</td>
<td>n&nbsp;log(n)</td>
<td>n<sup>2</sup></td>
<td>log(n)</td>
<td>No</td>
<td>Quicksort is usually done in-place with O(log(n)) stack space</td>
</tr>
<tr>
<td><strong>Shell sort</strong></td>
<td>n&nbsp;log(n)</td>
<td>depends on gap sequence</td>
<td>n&nbsp;(log(n))<sup>2</sup></td>
<td>1</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><strong>Counting sort</strong></td>
<td>n + r</td>
<td>n + r</td>
<td>n + r</td>
<td>n + r</td>
<td>Yes</td>
<td>r - biggest number in array</td>
</tr>
<tr>
<td><strong>Radix sort</strong></td>
<td>n * k</td>
<td>n * k</td>
<td>n * k</td>
<td>n + k</td>
<td>Yes</td>
<td>k - length of longest key</td>
</tr>
</tbody>
</table>

![overview diagram](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/assets/overview-diagram-of-data-structures.png)

![complexities](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/assets/complexities-diff.jpg)

![complexities of data structures](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/assets/data-structure-complexities.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/binary-tree/bst-rotation.gif)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/binary-tree/avl-tree-inserting.gif)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/tarjan.webp)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/adjacency-list.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/adjacency-list-pros-cons.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/adjacency-matrix.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/adjacency-matrix-pros-cons.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/dfs-can-do.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/edge-list.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/edge-list-pros-cons.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/max-flow.jpg)

![](https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/mst.jpg)

[//]: # (![]&#40;https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/tarjan-articulation-point-bridge.png&#41;)

[//]: # (![]&#40;https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/tarjan-complicate-simple.png&#41;)

[//]: # (![]&#40;https://github.com/zrwusa/assets/blob/master/images/data-structure-typed/graph/tarjan-strongly-connected-component.png&#41;)





